# ~/.config/i3d/50-auto-title-format.starlark
#
# Goal:
#   When a new X11 window opens, map its X11 identity to an i3 title_format and
#   apply it via i3 IPC.
#
# Notes:
#   - Prefer X11 WM_CLASS (window_properties.class / instance); fall back to
#     the node title (node["name"]) if needed.
#   - This Starlark dialect has no while-loops and forbids recursion; tree
#     walks are implemented with a bounded for-loop + explicit stack.
#
# Debug:
#   DEBUG=1 i3d

priority = 50

# Hardcoded mapping: X11 "window name" -> i3 title_format string.
# Prefer stable WM_CLASS names (window_properties.class / instance).
TITLE_FORMAT = {
    # Browsers
    "firefox": "ðŸ« %title",
    "chromium": "ðŸ« %title",
    # File managers
    "thunar": "ðŸ“‚ %title",
    "urxvt": "%title",
    "mpv": "ðŸ“¼ %title",
    # Browsers
    # Editors
    "code-oss": "[îœŒ] %title",
    "code": "[îœŒ] %title",
    "jetbrains-idea": "[îœŒ] %title",
    "jetbrains-clion": "[îœŒ] %title",
    "jetbrains-goland": "[îœŒ] %title",
}


def _dbg(msg):
    if debug:
        log("auto-title-format: " + msg)


def _as_list(v):
    if v == None:
        return []
    t = type(v)
    if t == "list" or t == "tuple":
        return v
    return []


def _wp_get(wp, key):
    if wp == None:
        return None
    if type(wp) != "dict":
        return None
    return wp.get(key, None)


def _i3_quote(s):
    # Quote for i3 command strings inside double-quotes.
    s = s.replace("\\", "\\\\")
    s = s.replace('"', '\\"')
    s = s.replace("\r", " ")
    s = s.replace("\n", " ")
    return s


def _find_focused(root):
    if root == None:
        return None

    stack = [root]

    # No while-loops; use a large bounded range and break/return.
    for _ in range(1000000):
        if len(stack) == 0:
            return None

        n = stack.pop()

        if n.get("focused", False):
            return n

        for c in _as_list(n.get("nodes", None)):
            stack.append(c)
        for c in _as_list(n.get("floating_nodes", None)):
            stack.append(c)

    _dbg("tree walk exceeded limit in _find_focused")
    return None


def _find_by_con_id(root, con_id):
    if root == None or con_id == None:
        return None

    stack = [root]

    for _ in range(1000000):
        if len(stack) == 0:
            return None

        n = stack.pop()

        if n.get("id", None) == con_id:
            return n

        for c in _as_list(n.get("nodes", None)):
            stack.append(c)
        for c in _as_list(n.get("floating_nodes", None)):
            stack.append(c)

    _dbg("tree walk exceeded limit in _find_by_con_id con_id=%s" % str(con_id))
    return None


def _pick_key(node):
    # Return (matched_key, fmt). If nothing matches, return a default.
    wp = node.get("window_properties", None)
    cls = _wp_get(wp, "class")
    inst = _wp_get(wp, "instance")
    name = node.get("name", None)

    # Stable order: class -> instance -> name (all lowercased for matching).
    if cls != None and type(cls) == "string":
        k = cls.lower()
        if k in TITLE_FORMAT:
            return (k, TITLE_FORMAT[k])

    if inst != None and type(inst) == "string":
        k = inst.lower()
        if k in TITLE_FORMAT:
            return (k, TITLE_FORMAT[k])

    if name != None and type(name) == "string":
        k = name.lower()
        if k in TITLE_FORMAT:
            return (k, TITLE_FORMAT[k])

    # Fallback: pick a best-effort key for debug, but always defined.
    fallback_key = "<default>"
    if cls != None and type(cls) == "string":
        fallback_key = cls.lower()
    elif inst != None and type(inst) == "string":
        fallback_key = inst.lower()
    elif name != None and type(name) == "string":
        fallback_key = name.lower()

    return (fallback_key, "ðŸ”© %title")


def _apply_title_format(con_id, fmt, matched_key, node):
    qfmt = _i3_quote(fmt)
    cmd = '[con_id="%s"] title_format "%s"' % (str(con_id), qfmt)

    if debug:
        wp = node.get("window_properties", None)
        cls = _wp_get(wp, "class")
        inst = _wp_get(wp, "instance")
        _dbg(
            "apply con_id=%s matched=%s class=%s instance=%s name=%s fmt=%s"
            % (
                str(con_id),
                str(matched_key),
                str(cls),
                str(inst),
                str(node.get("name", None)),
                str(fmt),
            )
        )
        _dbg("i3 cmd=" + cmd)

    ok = i3.command(cmd)
    if debug:
        _dbg("i3.command ok=%s" % str(ok))


def on_window(e):
    if e.get("change", "") != "new":
        return

    con_id = e.get("con_id", None)
    tree = i3.get_tree()

    node = None
    if con_id != None:
        node = _find_by_con_id(tree, con_id)
        if debug and node == None:
            _dbg("con_id=%s not found in tree; falling back to focused" % str(con_id))

    if node == None:
        node = _find_focused(tree)
        if node == None:
            _dbg("no focused node found for window new event")
            return
        con_id = node.get("id", None)

    if con_id == None:
        if debug:
            _dbg("no con_id available; cannot apply title_format")
        return

    matched_key, fmt = _pick_key(node)
    if fmt == None:
        if debug:
            wp = node.get("window_properties", None)
            cls = _wp_get(wp, "class")
            inst = _wp_get(wp, "instance")
            _dbg(
                "no match: con_id=%s class=%s instance=%s name=%s"
                % (
                    str(con_id),
                    str(cls),
                    str(inst),
                    str(node.get("name", None)),
                )
            )
        return

    _apply_title_format(con_id, fmt, matched_key, node)
