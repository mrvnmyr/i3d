# ~/.config/i3d/50-auto-title-format.starlark
#
# Goal:
#   When a new X11 window opens, map its "name" (prefer WM_CLASS) to an i3
#   title_format and apply it via i3 IPC.
#
# Notes:
#   - For X11, the most stable identifier is WM_CLASS -> window_properties.class
#     (and sometimes window_properties.instance).
#   - i3 tree fields:
#       node["name"]                     = current title
#       node["window_properties"]["class"]    = WM_CLASS class
#       node["window_properties"]["instance"] = WM_CLASS instance
#
# Debug:
#   Set DEBUG=1 when launching i3d to see extra logs from this script.

priority = 50

# Hardcoded mapping: X11 "window name" -> title_format string.
# Prefer stable WM_CLASS names (window_properties.class / instance).
#
# Replace/add entries to suit your setup.
TITLE_FORMAT = {
    # Browsers
    "Firefox": "[] %title",
    "firefox": "[] %title",

    # Terminals
    "Alacritty": "[] %title",
    "URxvt": "[] %title",
    "XTerm": "[] %title",

    # File managers
    "ranger": "[] %title",
    "Thunar": "[] %title",

    # Editors
    "code-oss": "[] %title",
    "Code": "[] %title",
    "jetbrains-idea": "[] %title",
    "jetbrains-clion": "[] %title",
    "jetbrains-goland": "[] %title",
}

def _dbg(msg):
    if debug:
        log("auto-title-format: " + msg)

def _as_list(v):
    if v == None:
        return []
    # Starlark doesn't have isinstance; rely on iteration behavior.
    # If v isn't iterable, return [].
    try:
        out = []
        for it in v:
            out.append(it)
        return out
    except:
        return []

def _find_focused(n):
    if n == None:
        return None
    if n.get("focused", False):
        return n

    for c in _as_list(n.get("nodes", None)):
        r = _find_focused(c)
        if r != None:
            return r
    for c in _as_list(n.get("floating_nodes", None)):
        r = _find_focused(c)
        if r != None:
            return r
    return None

def _find_by_con_id(n, con_id):
    if n == None or con_id == None:
        return None
    if n.get("id", None) == con_id:
        return n

    for c in _as_list(n.get("nodes", None)):
        r = _find_by_con_id(c, con_id)
        if r != None:
            return r
    for c in _as_list(n.get("floating_nodes", None)):
        r = _find_by_con_id(c, con_id)
        if r != None:
            return r
    return None

def _i3_quote(s):
    # Quote for i3 command strings inside double-quotes.
    # Keep it simple: escape backslashes and quotes; squash newlines.
    s = s.replace("\\", "\\\\")
    s = s.replace("\"", "\\\"")
    s = s.replace("\r", " ")
    s = s.replace("\n", " ")
    return s

def _pick_key(node):
    # Return (matched_key, title_format) or (None, None).
    if node == None:
        return (None, None)

    wp = node.get("window_properties", None)
    cls = None
    inst = None
    if wp != None:
        # wp is a dict for X11 windows; best-effort access.
        try:
            cls = wp.get("class", None)
            inst = wp.get("instance", None)
        except:
            cls = None
            inst = None

    name = node.get("name", None)

    # Try in stable order: class -> instance -> name.
    if cls != None and cls in TITLE_FORMAT:
        return (cls, TITLE_FORMAT[cls])
    if inst != None and inst in TITLE_FORMAT:
        return (inst, TITLE_FORMAT[inst])
    if name != None and name in TITLE_FORMAT:
        return (name, TITLE_FORMAT[name])

    # Also try lowercase variants (common for some apps).
    if cls != None:
        l = cls.lower()
        if l in TITLE_FORMAT:
            return (l, TITLE_FORMAT[l])
    if inst != None:
        l = inst.lower()
        if l in TITLE_FORMAT:
            return (l, TITLE_FORMAT[l])
    if name != None:
        l = name.lower()
        if l in TITLE_FORMAT:
            return (l, TITLE_FORMAT[l])

    return (None, None)

def _apply_title_format(con_id, fmt, matched_key, node):
    if con_id == None or fmt == None:
        return

    qfmt = _i3_quote(fmt)
    cmd = '[con_id="%s"] title_format "%s"' % (str(con_id), qfmt)

    if debug:
        wp = node.get("window_properties", None)
        cls = None
        inst = None
        if wp != None:
            try:
                cls = wp.get("class", None)
                inst = wp.get("instance", None)
            except:
                cls = None
                inst = None
        _dbg("apply con_id=%s matched=%s class=%s instance=%s name=%s fmt=%s" % (
            str(con_id), str(matched_key), str(cls), str(inst), str(node.get("name", None)), str(fmt),
        ))
        _dbg("i3 cmd=" + cmd)

    ok = i3.command(cmd)
    if debug:
        _dbg("i3.command ok=%s" % str(ok))

def on_window(e):
    # Apply only when a new window appears.
    if e.get("change", "") != "new":
        return

    # Prefer the enriched con_id (focused at dispatch time), then fall back to
    # the actually focused node.
    con_id = e.get("con_id", None)

    tree = i3.get_tree()

    node = None
    if con_id != None:
        node = _find_by_con_id(tree, con_id)
        if debug and node == None:
            _dbg("con_id=%s not found in tree; falling back to focused" % str(con_id))

    if node == None:
        node = _find_focused(tree)
        if node == None:
            if debug:
                _dbg("no focused node found for window new event")
            return
        con_id = node.get("id", None)

    matched_key, fmt = _pick_key(node)
    if fmt == None:
        if debug:
            wp = node.get("window_properties", None)
            cls = None
            inst = None
            if wp != None:
                try:
                    cls = wp.get("class", None)
                    inst = wp.get("instance", None)
                except:
                    cls = None
                    inst = None
            _dbg("no match for new window: con_id=%s class=%s instance=%s name=%s" % (
                str(con_id), str(cls), str(inst), str(node.get("name", None)),
            ))
        return

    _apply_title_format(con_id, fmt, matched_key, node)
